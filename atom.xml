<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王彪的个人博客</title>
  <subtitle>www.wangbiaozy.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-01T02:19:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangbiaozy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git的使用与常用linux命令</title>
    <link href="http://yoursite.com/2016/12/31/git%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/12/31/git的使用与常用linux命令/</id>
    <published>2016-12-31T15:49:55.000Z</published>
    <updated>2017-01-01T02:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>　　为了告别手动方式管理Linux代码,并且符合开源和免费,Linus花了两周时间自己用 C 写了一个分布式版本控制系统，这就是Git。<br>　　Git迅速成为最流行的分布式版本控制系统，尤其是 2008 年 GitHub 网站上线了，它为开源项目 免费提供Git存储 ，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<a id="more"></a>
<h3 id="1-git的安装"><a href="#1-git的安装" class="headerlink" title="1. git的安装"></a>1. git的安装</h3><ul>
<li>windows下的安装<br>下载地址: <a href="http://git-scm.com" target="_blank" rel="external">http://git-scm.com</a><blockquote>
<p>windows安装过程中记得选择在cmd下使用linux命令</p>
</blockquote>
</li>
<li>mac下安装<br>下载HomeBrew: <a href="http://brew.sh" target="_blank" rel="external">http://brew.sh</a><br>拷贝对应脚本到终端下安装HomeBrew<br>然后在终端执行brew install git命令安装git<blockquote>
<p>安装xcode会默认下载git</p>
</blockquote>
</li>
</ul>
<h3 id="2-配置git用户和邮箱"><a href="#2-配置git用户和邮箱" class="headerlink" title="2. 配置git用户和邮箱"></a>2. 配置git用户和邮箱</h3><pre><code>$ git config --global user.name &quot;你的github用户名&quot;
$ git config --global user.email &quot;你的github邮箱&quot;
</code></pre><blockquote>
<p>不配置用户名和邮箱的话无法提交，因为git不知道你是谁    </p>
</blockquote>
<p>查看配置</p>
<pre><code>$ git config --global user.name
$ git config --global user.email
</code></pre><p>查看所有配置</p>
<pre><code>$git config --list    
</code></pre><h3 id="3-初始化git"><a href="#3-初始化git" class="headerlink" title="3. 初始化git"></a>3. 初始化git</h3><ul>
<li>先创建一个空目录，可以直接手动创建，也可以在终端或命令行中输入mkdir 文件夹的名字 来创建，然后进入此目录，手动进入或在终端或命令行中输入cd（change directory）文件夹的名字，进入此目录（删除文件夹使用<code>$ rm -rf 文件夹名字</code>）</li>
<li>windows在当前文件夹右键点击Git Bash Here打开命令行，mac在当前文件选择在此打开终端窗口，或者直接在cmd命令行或终端里输入 git init 来初始化git，告诉git当前目录归它所管理</li>
</ul>
<blockquote>
<p>通过ls -al 命令查看当前目录下的所有文件</p>
</blockquote>
<h3 id="4-git中的三个区"><a href="#4-git中的三个区" class="headerlink" title="4. git中的三个区"></a>4. git中的三个区</h3><p><a href="http://card.mugeda.com/campaigns/56d2c4a0a3664e3308000407/20160304090522/56d97729a3664e9c65000047/index.html" target="_blank" rel="external">git的工作流</a></p>
<h4 id="4-1-工作区"><a href="#4-1-工作区" class="headerlink" title="4.1 工作区"></a>4.1 工作区</h4><p>通过git add 添加到暂存区</p>
<pre><code>$ git add ./-a/文件名
</code></pre><blockquote>
<p>当前文件在命令行或终端里没有加入到暂存区是红色，加入后是绿色 可以通过<code>$ git status</code>命令查看；这里说几个常用的linux命令：</p>
</blockquote>
<pre><code>$ touch 文件名  //创建文件
$ echo 内容 &gt;&gt; 1.txt  //一个大于号清空 创建 并写入 两个大于号追加
$ cat 文件名  //查看文件
$ vi 文件名  //修改文件 i键进入编辑状态 esc退出 :wq保存并退出  :q!强制退出
</code></pre><h4 id="4-2-暂存区"><a href="#4-2-暂存区" class="headerlink" title="4.2 暂存区"></a>4.2 暂存区</h4><p>特点：过渡的作用，避免误操作，保护工作区和历史区，分支处理；<br>通过git commit添加到历史区</p>
<pre><code>$ git commit -m &apos;注释内容&apos;    
</code></pre><h4 id="4-3-历史区"><a href="#4-3-历史区" class="headerlink" title="4.3 历史区"></a>4.3 历史区</h4><p>历史区的内容只要电脑不爆炸、不手动删除.git文件，内容永远不会丢失<br>查看历史状态及提交版本号：</p>
<pre><code>$ git log / $ git log --oneline   //在命令末尾添加--oneline显示记录为一行    
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　为了告别手动方式管理Linux代码,并且符合开源和免费,Linus花了两周时间自己用 C 写了一个分布式版本控制系统，这就是Git。&lt;br&gt;　　Git迅速成为最流行的分布式版本控制系统，尤其是 2008 年 GitHub 网站上线了，它为开源项目 免费提供Git存储 ，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>时间字符串格式化</title>
    <link href="http://yoursite.com/2016/12/22/%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://yoursite.com/2016/12/22/时间字符串格式化/</id>
    <published>2016-12-21T18:44:55.000Z</published>
    <updated>2016-12-21T20:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>　　利用正则在String原型上添加一个方法：把指定时间格式的字符串换成我们想要的各种格式,例如我们有时需要把“2016-12-22 03:10:00”或者“2016/12/22 03:10:00”等时间字符串换成我们想要的2016年12月22日 3时10分0秒等形式展示出来，那么利用正则以及String中的replace方法来实现是个简便而又实用的方法</p>
<a id="more"></a>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><pre><code>String.prototype.myFormatTime = function (){
    var reg = /^(\d{4})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?:\s+)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})$/g;
    var arr = [];
    this.replace(reg, function (){
        arr = ([].slice.call(arguments)).slice(1,7);
    });
    var format = arguments[0] || &quot;{0}年{1}月{2}日 {3}:{4}:{5}&quot;;
    return format.replace(/{(\d+)}/g,function (){
        var val = arr[arguments[1]];
        return val.length === 1 ? &quot;0&quot; + val : val;
    });
}    
</code></pre><h4 id="让我们来试一下这个方法"><a href="#让我们来试一下这个方法" class="headerlink" title="让我们来试一下这个方法"></a>让我们来试一下这个方法</h4><pre><code>var str1 = &quot;2016-12-22 03:29:35&quot;,str2 = &quot;2016/12/22 3:29:35&quot;,str3 = &quot;2016.12.22 3.29.35&quot;;
console.log(str1.myFormatTime(&quot;{0}年{1}月{2}日 {3}时{4}分{5}秒&quot;)); //这里输出的是2016年12月22日 03时29分35秒
console.log(str2.myFormatTime(&quot;{1}月{2}日 {3}时{4}分&quot;)); //这里输出的是12月22日 03时29分
console.log(str3.myFormatTime(&quot;{1}月{2}日 {3}时{4}分&quot;)); //这里输出的同样是12月22日 03时29分
</code></pre><h4 id="需要注意的是当replace方法的第二个参数是一个函数的时候，函数中arguments这个类数组中存放了哪几项，以及如何把我们所需要的项提取到一个数组中。"><a href="#需要注意的是当replace方法的第二个参数是一个函数的时候，函数中arguments这个类数组中存放了哪几项，以及如何把我们所需要的项提取到一个数组中。" class="headerlink" title="需要注意的是当replace方法的第二个参数是一个函数的时候，函数中arguments这个类数组中存放了哪几项，以及如何把我们所需要的项提取到一个数组中。"></a>需要注意的是当replace方法的第二个参数是一个函数的时候，函数中arguments这个类数组中存放了哪几项，以及如何把我们所需要的项提取到一个数组中。</h4><pre><code>this.replace(reg, function (){
        console.log(arguments);//输出arguments为[&quot;2016-12-22 03:29:35&quot;, &quot;2016&quot;, &quot;12&quot;, &quot;22&quot;, &quot;03&quot;, &quot;29&quot;, &quot;35&quot;, 0, &quot;2016-12-22 03:29:35&quot;]，可以看到第2到第7项是我们所需要的，也就是索引1到索引6的项
        arr = ([].slice.call(arguments)).slice(1,7);//借用数组中的slice方法将我们需要的项复制到一个新的数组中，这里需要注意slice传两个参数时是从索引1开始到索引7但是不包含索引7，这里千万不要写成6
    });
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　利用正则在String原型上添加一个方法：把指定时间格式的字符串换成我们想要的各种格式,例如我们有时需要把“2016-12-22 03:10:00”或者“2016/12/22 03:10:00”等时间字符串换成我们想要的2016年12月22日 3时10分0秒等形式展示出来，那么利用正则以及String中的replace方法来实现是个简便而又实用的方法&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JS中的DOM映射、重绘和回流</title>
    <link href="http://yoursite.com/2016/12/14/JS%E4%B8%AD%E7%9A%84DOM%E6%98%A0%E5%B0%84%E3%80%81%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"/>
    <id>http://yoursite.com/2016/12/14/JS中的DOM映射、重绘和回流/</id>
    <published>2016-12-14T02:42:41.000Z</published>
    <updated>2016-12-14T07:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>　　先来简单了解下什么是DOM映射、重绘和回流–&gt;DOM映射：通过DOM方式获取来的DOM对象和网页内元素的一一对应关系；DOM重绘：页面内元素样式等的改变；DOM回流：页面内元素的增加和删除或者位置的改变都会引起DOM回流。 </p>
<a id="more"></a>
<p>　　 </p>
<h4 id="为了方便理解，我们来看一个简单的小例子，假设页面中有如下一个ul标签，我们需要把ul下的每一个li重新排序再添加到页面中-这里为了方便所以将样式写在行内"><a href="#为了方便理解，我们来看一个简单的小例子，假设页面中有如下一个ul标签，我们需要把ul下的每一个li重新排序再添加到页面中-这里为了方便所以将样式写在行内" class="headerlink" title="为了方便理解，我们来看一个简单的小例子，假设页面中有如下一个ul标签，我们需要把ul下的每一个li重新排序再添加到页面中(这里为了方便所以将样式写在行内)"></a>为了方便理解，我们来看一个简单的小例子，假设页面中有如下一个ul标签，我们需要把ul下的每一个li重新排序再添加到页面中(这里为了方便所以将样式写在行内)</h4><pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;demo&lt;/title&gt;
        &lt;style&gt;
            *{
                margin: 0;
                padding: 0;
            }
            ul{
                margin: 30px auto;
                padding: 10px;
                border: 3px solid #ccc;
                list-style: none;
            }
            ul li{
                margin-bottom: 3px;
                height: 30px;
                line-height: 30px;
                text-align: center;
                background: lightgreen;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;ul&gt;
            &lt;li&gt;3&lt;/li&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;4&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
        &lt;/ul&gt;        
    &lt;/body&gt;
&lt;/html&gt;        
</code></pre><h4 id="js代码如下："><a href="#js代码如下：" class="headerlink" title="js代码如下："></a>js代码如下：</h4><pre><code>&lt;script&gt;  
    var ul = document.getElementById(&quot;list&quot;);  
    var lis = ul.getElementsByTagName(&quot;li&quot;);
    var lisArr = listToArray(lis);//把lis从类数组转化成数组
    console.dir(lisArr);
    lisArr.sort(function(a,b){
        return a.innerHTML - b.innerHTML;
        //如果是字符串则需要使用localeCompare 
    });
    for (var i=0; i&lt;lisArr.length; i++){
        ul.appendChild(lisArr[i]); //把重新排序好的每一个li添加回页面中
        lisArr[i].onmouseover = function (){ //鼠标划过每个li改变当前li颜色  
            this.style.backgroundColor = &apos;red&apos;;
        }
        lisArr[i].onmouseout = function (){ //鼠标划出当前li变回原来颜色
            this.style.backgroundColor = &apos;lightgreen&apos;;
        }
    }
&lt;/script&gt;
</code></pre><h4 id="类数组转数组："><a href="#类数组转数组：" class="headerlink" title="类数组转数组："></a>类数组转数组：</h4><pre><code>function listToArray(likeArray){
    try{
        return Array.prototype.slice.call(likeArray);
    }catch(e){
        var a = [];
        for (var i=0; i&lt;likeArray.length; i++){
            a[a.length] = likeArray[i];
        }
        return a;
    }
}
</code></pre><h4 id="以上的操作是比较浪费性能的，因为页面内元素的增加、删除或者位置的改变都会引发DOM回流并且li的样式发生过改变引发了DOM重绘（相对于回流来说性能开销很小），那我们该如何处理这个问题呢？在解决这个问题之前我们先用js在页面内增加两个li元素，先来看看第一种方法："><a href="#以上的操作是比较浪费性能的，因为页面内元素的增加、删除或者位置的改变都会引发DOM回流并且li的样式发生过改变引发了DOM重绘（相对于回流来说性能开销很小），那我们该如何处理这个问题呢？在解决这个问题之前我们先用js在页面内增加两个li元素，先来看看第一种方法：" class="headerlink" title="以上的操作是比较浪费性能的，因为页面内元素的增加、删除或者位置的改变都会引发DOM回流并且li的样式发生过改变引发了DOM重绘（相对于回流来说性能开销很小），那我们该如何处理这个问题呢？在解决这个问题之前我们先用js在页面内增加两个li元素，先来看看第一种方法："></a>以上的操作是比较浪费性能的，因为页面内元素的增加、删除或者位置的改变都会引发DOM回流并且li的样式发生过改变引发了DOM重绘（相对于回流来说性能开销很小），那我们该如何处理这个问题呢？在解决这个问题之前我们先用js在页面内增加两个li元素，先来看看第一种方法：</h4><pre><code>for (var i=1; i&lt;=2; i++){
    var li = document.createElement(&apos;li&apos;);
    li.innerHTML = i+4;
    ul.appendChild(li); //注意：这行代码执行一次就会引起一次回流 如果循环中的i=10000 就会引起一万次回流...
}
</code></pre><h4 id="再来看看第二种方法："><a href="#再来看看第二种方法：" class="headerlink" title="再来看看第二种方法："></a>再来看看第二种方法：</h4><pre><code>var str = &quot;&quot;;
for (var i=1; i&lt;=2; i++){
    str +=&apos;&lt;li&gt;&apos;+(i+4)+&apos;&lt;/li&gt;&apos;;
}    
ul.innerHTML += str; //这种是先到ul中把html字符串拿来，然后再拼接字符串，最后把拼接好的字符串放到页面内重新渲染。导致了原有的事件属性（onmouseover onmouseout）丢失
</code></pre><h4 id="以上都不是我们想要的结果，那么通过什么样地方式，既能保证原有事件不丢失，还能尽可能少的引起DOM回流呢？如果能提供一个容器，用来存放每次创建的li-最后把这个容器一次放到页面中就会仅仅引起一次回流，让我们来看下该如何实现："><a href="#以上都不是我们想要的结果，那么通过什么样地方式，既能保证原有事件不丢失，还能尽可能少的引起DOM回流呢？如果能提供一个容器，用来存放每次创建的li-最后把这个容器一次放到页面中就会仅仅引起一次回流，让我们来看下该如何实现：" class="headerlink" title="以上都不是我们想要的结果，那么通过什么样地方式，既能保证原有事件不丢失，还能尽可能少的引起DOM回流呢？如果能提供一个容器，用来存放每次创建的li,最后把这个容器一次放到页面中就会仅仅引起一次回流，让我们来看下该如何实现："></a>以上都不是我们想要的结果，那么通过什么样地方式，既能保证原有事件不丢失，还能尽可能少的引起DOM回流呢？如果能提供一个容器，用来存放每次创建的li,最后把这个容器一次放到页面中就会仅仅引起一次回流，让我们来看下该如何实现：</h4><pre><code>var frg = document.createDocumentFragment(); //这个就是我们需要的容器，叫做文档碎片，专门用来存储DOM元素的
for (var i=1; i&lt;=3; i++){
    var li = document.createElement(&apos;li&apos;);
    li.innerHTML = i+4;
    frg.appendChild(li);
}
ul.appendChild(frg); //把这个容器中所包含的三个li一次性添加到ul中
frg = null; //添加之后这个容器就没用了 记得丢掉
</code></pre><h4 id="最后总结一下上面三种方法："><a href="#最后总结一下上面三种方法：" class="headerlink" title="最后总结一下上面三种方法："></a>最后总结一下上面三种方法：</h4><p>appendChild：会引起多次回流，但是原有DOM元素的属性不会丢失<br>innerHTML：只有一次回流，但是导致原有DOM元素的属性丢失<br>document.cteateDocumentFragment：只有一次回流并且原有DOM元素的属性不会丢失<br>ps:如果页面内不是追加元素使用innerHTML就可以        </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　先来简单了解下什么是DOM映射、重绘和回流–&amp;gt;DOM映射：通过DOM方式获取来的DOM对象和网页内元素的一一对应关系；DOM重绘：页面内元素样式等的改变；DOM回流：页面内元素的增加和删除或者位置的改变都会引起DOM回流。 &lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
</feed>
