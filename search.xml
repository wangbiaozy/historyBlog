<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[时间字符串格式化]]></title>
      <url>%2F2016%2F12%2F22%2F%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[利用正则在String原型上添加一个方法：把指定时间格式的字符串换成我们想要的各种格式,例如我们有时需要把“2016-12-22 03:10:00”或者“2016/12/22 03:10:00”等时间字符串换成我们想要的2016年12月22日 3时10分0秒等形式展示出来，那么利用正则以及String中的replace方法来实现是个简便而又实用的方法 代码如下String.prototype.myFormatTime = function (){ var reg = /^(\d{4})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?:\s+)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})$/g; var arr = []; this.replace(reg, function (){ arr = ([].slice.call(arguments)).slice(1,7); }); var format = arguments[0] || &quot;{0}年{1}月{2}日 {3}:{4}:{5}&quot;; return format.replace(/{(\d+)}/g,function (){ var val = arr[arguments[1]]; return val.length === 1 ? &quot;0&quot; + val : val; }); } 让我们来试一下这个方法var str1 = &quot;2016-12-22 03:29:35&quot;,str2 = &quot;2016/12/22 3:29:35&quot;,str3 = &quot;2016.12.22 3.29.35&quot;; console.log(str1.myFormatTime(&quot;{0}年{1}月{2}日 {3}时{4}分{5}秒&quot;)); //这里输出的是2016年12月22日 03时29分35秒 console.log(str2.myFormatTime(&quot;{1}月{2}日 {3}时{4}分&quot;)); //这里输出的是12月22日 03时29分 console.log(str3.myFormatTime(&quot;{1}月{2}日 {3}时{4}分&quot;)); //这里输出的同样是12月22日 03时29分 需要注意的是当replace方法的第二个参数是一个函数的时候，函数中arguments这个类数组中存放了哪几项，以及如何把我们所需要的项提取到一个数组中。this.replace(reg, function (){ console.log(arguments);//输出arguments为[&quot;2016-12-22 03:29:35&quot;, &quot;2016&quot;, &quot;12&quot;, &quot;22&quot;, &quot;03&quot;, &quot;29&quot;, &quot;35&quot;, 0, &quot;2016-12-22 03:29:35&quot;]，可以看到第2到第7项是我们所需要的，也就是索引1到索引6的项 arr = ([].slice.call(arguments)).slice(1,7);//借用数组中的slice方法将我们需要的项复制到一个新的数组中，这里需要注意slice传两个参数时是从索引1开始到索引7但是不包含索引7，这里千万不要写成6 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的DOM映射、重绘和回流]]></title>
      <url>%2F2016%2F12%2F14%2FJS%E4%B8%AD%E7%9A%84DOM%E6%98%A0%E5%B0%84%E3%80%81%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%2F</url>
      <content type="text"><![CDATA[先来简单了解下什么是DOM映射、重绘和回流–&gt;DOM映射：通过DOM方式获取来的DOM对象和网页内元素的一一对应关系；DOM重绘：页面内元素样式等的改变；DOM回流：页面内元素的增加和删除或者位置的改变都会引起DOM回流。 为了方便理解，我们来看一个简单的小例子，假设页面中有如下一个ul标签，我们需要把ul下的每一个li重新排序再添加到页面中(这里为了方便所以将样式写在行内)&lt;html&gt; &lt;head&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } ul{ margin: 30px auto; padding: 10px; border: 3px solid #ccc; list-style: none; } ul li{ margin-bottom: 3px; height: 30px; line-height: 30px; text-align: center; background: lightgreen; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; js代码如下：&lt;script&gt; var ul = document.getElementById(&quot;list&quot;); var lis = ul.getElementsByTagName(&quot;li&quot;); var lisArr = listToArray(lis);//把lis从类数组转化成数组 console.dir(lisArr); lisArr.sort(function(a,b){ return a.innerHTML - b.innerHTML; //如果是字符串则需要使用localeCompare }); for (var i=0; i&lt;lisArr.length; i++){ ul.appendChild(lisArr[i]); //把重新排序好的每一个li添加回页面中 lisArr[i].onmouseover = function (){ //鼠标划过每个li改变当前li颜色 this.style.backgroundColor = &apos;red&apos;; } lisArr[i].onmouseout = function (){ //鼠标划出当前li变回原来颜色 this.style.backgroundColor = &apos;lightgreen&apos;; } } &lt;/script&gt; 类数组转数组：function listToArray(likeArray){ try{ return Array.prototype.slice.call(likeArray); }catch(e){ var a = []; for (var i=0; i&lt;likeArray.length; i++){ a[a.length] = likeArray[i]; } return a; } } 以上的操作是比较浪费性能的，因为页面内元素的增加、删除或者位置的改变都会引发DOM回流并且li的样式发生过改变引发了DOM重绘（相对于回流来说性能开销很小），那我们该如何处理这个问题呢？在解决这个问题之前我们先用js在页面内增加两个li元素，先来看看第一种方法：for (var i=1; i&lt;=2; i++){ var li = document.createElement(&apos;li&apos;); li.innerHTML = i+4; ul.appendChild(li); //注意：这行代码执行一次就会引起一次回流 如果循环中的i=10000 就会引起一万次回流... } 再来看看第二种方法：var str = &quot;&quot;; for (var i=1; i&lt;=2; i++){ str +=&apos;&lt;li&gt;&apos;+(i+4)+&apos;&lt;/li&gt;&apos;; } ul.innerHTML += str; //这种是先到ul中把html字符串拿来，然后再拼接字符串，最后把拼接好的字符串放到页面内重新渲染。导致了原有的事件属性（onmouseover onmouseout）丢失 以上都不是我们想要的结果，那么通过什么样地方式，既能保证原有事件不丢失，还能尽可能少的引起DOM回流呢？如果能提供一个容器，用来存放每次创建的li,最后把这个容器一次放到页面中就会仅仅引起一次回流，让我们来看下该如何实现：var frg = document.createDocumentFragment(); //这个就是我们需要的容器，叫做文档碎片，专门用来存储DOM元素的 for (var i=1; i&lt;=3; i++){ var li = document.createElement(&apos;li&apos;); li.innerHTML = i+4; frg.appendChild(li); } ul.appendChild(frg); //把这个容器中所包含的三个li一次性添加到ul中 frg = null; //添加之后这个容器就没用了 记得丢掉 最后总结一下上面三种方法：appendChild：会引起多次回流，但是原有DOM元素的属性不会丢失innerHTML：只有一次回流，但是导致原有DOM元素的属性丢失document.cteateDocumentFragment：只有一次回流并且原有DOM元素的属性不会丢失ps:如果页面内不是追加元素使用innerHTML就可以]]></content>
    </entry>

    
  
  
</search>
