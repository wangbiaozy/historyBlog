<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[git的使用与常用linux命令]]></title>
      <url>%2F2016%2F12%2F31%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[为了告别手动方式管理Linux代码,并且符合开源和免费,Linus花了两周时间自己用 C 写了一个分布式版本控制系统，这就是Git。 Git迅速成为最流行的分布式版本控制系统，尤其是 2008 年 GitHub 网站上线了，它为开源项目 免费提供Git存储 ，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 1. git的安装 windows下的安装下载地址: http://git-scm.com windows安装过程中记得选择在cmd下使用linux命令 mac下安装下载HomeBrew: http://brew.sh拷贝对应脚本到终端下安装HomeBrew 然后在终端执行brew install git命令安装git 安装xcode会默认下载git 2. 配置git用户和邮箱$ git config --global user.name &quot;你的github用户名&quot; $ git config --global user.email &quot;你的github邮箱&quot; 不配置用户名和邮箱的话无法提交，因为git不知道你是谁 查看配置 $ git config --global user.name $ git config --global user.email 查看所有配置 $git config --list 3. 初始化git 先创建一个空目录，可以直接手动创建，也可以在终端或命令行中输入mkdir 文件夹的名字 来创建，然后进入此目录，手动进入或在终端或命令行中输入cd（change directory）文件夹的名字，进入此目录（删除文件夹使用$ rm -rf 文件夹名字） windows在当前文件夹右键点击Git Bash Here打开命令行，mac在当前文件选择在此打开终端窗口，或者直接在cmd命令行或终端里输入 git init 来初始化git，告诉git当前目录归它所管理 通过ls -al 命令查看当前目录下的所有文件 4. git中的三个区git的工作流 4.1 工作区通过git add 添加到暂存区 $ git add ./-a/文件名 当前文件在命令行或终端里没有加入到暂存区是红色，加入后是绿色 可以通过$ git status命令查看；这里说几个常用的linux命令： $ touch 文件名 //创建文件 $ echo 内容 &gt;&gt; 1.txt //一个大于号清空 创建 并写入 两个大于号追加 $ cat 文件名 //查看文件 $ vi 文件名 //修改文件 i键进入编辑状态 esc退出 :wq保存并退出 :q!强制退出 4.2 暂存区特点：过渡的作用，避免误操作，保护工作区和历史区，分支处理；通过git commit添加到历史区 $ git commit -m &apos;注释内容&apos; 4.3 历史区历史区的内容只要电脑不爆炸、不手动删除.git文件，内容永远不会丢失查看历史状态及提交版本号： $ git log / $ git log --oneline //在命令末尾添加--oneline显示记录为一行 一步提交到历史区： $ git commit -a -m&apos;注释内容&apos; //如果当前文件是首次提交则不支持此命令，需要逐步提交 有的时候我们希望提交时合并到上一次的提交: $ git commit --amend 在历史区中查询关键字： $ git log --grep/--author=提交者名字 5. 不同区的代码比较5.1 工作区和暂存区$ git diff 5.2 暂存区和历史区$ git diff --cached 5.3 工作区和历史区$ git diff 分支的名字 6. 撤销6.1 撤销回暂存区中新加的内容（git add的内容）$ git reset HEAD 文件名 6.2 撤回文件先从暂存区撤销，暂存区无内容，从历史区撤销 $ git checkout 文件名 7. 删除7.1 删除暂存区和工作区删除暂存区中的内容,并且保证工作区中的内容已经不存在 $ git rm 文件名 //若本地文件存在则不能删除，需要通过-f参数删除 7.2 仅删除暂存区$ git rm --cached 文件名 8. 恢复（版本回退）8.1 版本回退（历史区→工作区）$ git reset --hard 版本号 $ git reset --hard HEAD~3 // HEAD^去上一级 8.2 查看操作历史$ git log //查看当前版本之前的内容 $ git reflog //查看所有操作历史 9. 分支主要是写代码时，不会影响主代码 9.1 创建分支$ git branch 分支名字 9.2 查看分支$ git branch 9.3 进入到分支（切换分支）$ git checkout 分支名 9.4 删除分支$ git branch -D 分支名 9.5 创建并切入分支$ git checkout -b dev //创建并切入到dev分支上 9.6 合并分支$ git merge 被合并的分支名 每个人都会拥有一条分支，开发自己的代码，自己的代码开发完成后提交到自己的历史区，主分支来进行合并分支 ，注意区分主分支 9.7 合并分支时产生冲突的原因两个人同时改变了同一个文件。git不知道谁是对的，要让自己裁决，裁决好后再次提交。只能手动合并。 10. 将本地内容推送到远程仓库10.1 关联远程仓库$ git remote add origin（地址名） 远程仓库地址 10.2 移除关联的远程仓库$ git remote rm origin（地址名） 10.3 查看关联的远程仓库信息查看仓库名字 $ git remote 查看仓库地址 $ git remote -v 10.4 推送到远程仓库要保证即将被推送到远程的内容已经添加到历史区，即已经执行过$ git add . &amp;&amp; git commit -m&quot;&quot;，否则无法推送到远程仓库 $ git push origin master //可以选择加不加-u(upstream)参数 首次推送如果加-u则以后每次拉取和推送直接执行git pull/git push即可 如果本地和线上版本不一致，则需先进行拉取，如果拉取后有冲突，需要手动解决冲突，然后再推送 强制覆盖远程仓库内容：$ git push origin master -f（谨慎使用此命令…后果很严重，你懂的…）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间字符串格式化]]></title>
      <url>%2F2016%2F12%2F22%2F%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
      <content type="text"><![CDATA[利用正则在String原型上添加一个方法：把指定时间格式的字符串换成我们想要的各种格式,例如我们有时需要把“2016-12-22 03:10:00”或者“2016/12/22 03:10:00”等时间字符串换成我们想要的2016年12月22日 3时10分0秒等形式展示出来，那么利用正则以及String中的replace方法来实现是个简便而又实用的方法 代码如下String.prototype.myFormatTime = function (){ var reg = /^(\d{4})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?:\s+)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})(?:-|\/|\.|:)(\d{1,2})$/g; var arr = []; this.replace(reg, function (){ arr = ([].slice.call(arguments)).slice(1,7); }); var format = arguments[0] || &quot;{0}年{1}月{2}日 {3}:{4}:{5}&quot;; return format.replace(/{(\d+)}/g,function (){ var val = arr[arguments[1]]; return val.length === 1 ? &quot;0&quot; + val : val; }); } 让我们来试一下这个方法var str1 = &quot;2016-12-22 03:29:35&quot;,str2 = &quot;2016/12/22 3:29:35&quot;,str3 = &quot;2016.12.22 3.29.35&quot;; console.log(str1.myFormatTime(&quot;{0}年{1}月{2}日 {3}时{4}分{5}秒&quot;)); //这里输出的是2016年12月22日 03时29分35秒 console.log(str2.myFormatTime(&quot;{1}月{2}日 {3}时{4}分&quot;)); //这里输出的是12月22日 03时29分 console.log(str3.myFormatTime(&quot;{1}月{2}日 {3}时{4}分&quot;)); //这里输出的同样是12月22日 03时29分 需要注意的是当replace方法的第二个参数是一个函数的时候，函数中arguments这个类数组中存放了哪几项，以及如何把我们所需要的项提取到一个数组中。this.replace(reg, function (){ console.log(arguments);//输出arguments为[&quot;2016-12-22 03:29:35&quot;, &quot;2016&quot;, &quot;12&quot;, &quot;22&quot;, &quot;03&quot;, &quot;29&quot;, &quot;35&quot;, 0, &quot;2016-12-22 03:29:35&quot;]，可以看到第2到第7项是我们所需要的，也就是索引1到索引6的项 arr = ([].slice.call(arguments)).slice(1,7);//借用数组中的slice方法将我们需要的项复制到一个新的数组中，这里需要注意slice传两个参数时是从索引1开始到索引7但是不包含索引7，这里千万不要写成6 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的DOM映射、重绘和回流]]></title>
      <url>%2F2016%2F12%2F14%2FJS%E4%B8%AD%E7%9A%84DOM%E6%98%A0%E5%B0%84%E3%80%81%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%2F</url>
      <content type="text"><![CDATA[先来简单了解下什么是DOM映射、重绘和回流–&gt;DOM映射：通过DOM方式获取来的DOM对象和网页内元素的一一对应关系；DOM重绘：页面内元素样式等的改变；DOM回流：页面内元素的增加和删除或者位置的改变都会引起DOM回流。 为了方便理解，我们来看一个简单的小例子，假设页面中有如下一个ul标签，我们需要把ul下的每一个li重新排序再添加到页面中(这里为了方便所以将样式写在行内)&lt;html&gt; &lt;head&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } ul{ margin: 30px auto; padding: 10px; border: 3px solid #ccc; list-style: none; } ul li{ margin-bottom: 3px; height: 30px; line-height: 30px; text-align: center; background: lightgreen; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; js代码如下：&lt;script&gt; var ul = document.getElementById(&quot;list&quot;); var lis = ul.getElementsByTagName(&quot;li&quot;); var lisArr = listToArray(lis);//把lis从类数组转化成数组 console.dir(lisArr); lisArr.sort(function(a,b){ return a.innerHTML - b.innerHTML; //如果是字符串则需要使用localeCompare }); for (var i=0; i&lt;lisArr.length; i++){ ul.appendChild(lisArr[i]); //把重新排序好的每一个li添加回页面中 lisArr[i].onmouseover = function (){ //鼠标划过每个li改变当前li颜色 this.style.backgroundColor = &apos;red&apos;; } lisArr[i].onmouseout = function (){ //鼠标划出当前li变回原来颜色 this.style.backgroundColor = &apos;lightgreen&apos;; } } &lt;/script&gt; 类数组转数组：function listToArray(likeArray){ try{ return Array.prototype.slice.call(likeArray); }catch(e){ var a = []; for (var i=0; i&lt;likeArray.length; i++){ a[a.length] = likeArray[i]; } return a; } } 以上的操作是比较浪费性能的，因为页面内元素的增加、删除或者位置的改变都会引发DOM回流并且li的样式发生过改变引发了DOM重绘（相对于回流来说性能开销很小），那我们该如何处理这个问题呢？在解决这个问题之前我们先用js在页面内增加两个li元素，先来看看第一种方法：for (var i=1; i&lt;=2; i++){ var li = document.createElement(&apos;li&apos;); li.innerHTML = i+4; ul.appendChild(li); //注意：这行代码执行一次就会引起一次回流 如果循环中的i=10000 就会引起一万次回流... } 再来看看第二种方法：var str = &quot;&quot;; for (var i=1; i&lt;=2; i++){ str +=&apos;&lt;li&gt;&apos;+(i+4)+&apos;&lt;/li&gt;&apos;; } ul.innerHTML += str; //这种是先到ul中把html字符串拿来，然后再拼接字符串，最后把拼接好的字符串放到页面内重新渲染。导致了原有的事件属性（onmouseover onmouseout）丢失 以上都不是我们想要的结果，那么通过什么样地方式，既能保证原有事件不丢失，还能尽可能少的引起DOM回流呢？如果能提供一个容器，用来存放每次创建的li,最后把这个容器一次放到页面中就会仅仅引起一次回流，让我们来看下该如何实现：var frg = document.createDocumentFragment(); //这个就是我们需要的容器，叫做文档碎片，专门用来存储DOM元素的 for (var i=1; i&lt;=3; i++){ var li = document.createElement(&apos;li&apos;); li.innerHTML = i+4; frg.appendChild(li); } ul.appendChild(frg); //把这个容器中所包含的三个li一次性添加到ul中 frg = null; //添加之后这个容器就没用了 记得丢掉 最后总结一下上面三种方法：appendChild：会引起多次回流，但是原有DOM元素的属性不会丢失innerHTML：只有一次回流，但是导致原有DOM元素的属性丢失document.cteateDocumentFragment：只有一次回流并且原有DOM元素的属性不会丢失ps:如果页面内不是追加元素使用innerHTML就可以]]></content>
    </entry>

    
  
  
</search>
